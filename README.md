Я создала очень простую библиотеку, которая принимает два числа и складывает их. Библиотека будет достаточно простой.
1.Создадим структуру нашего проекта. Для этого мы создадим очень простую структуру проекта. Давайте создадим структуру и добавим файл index.js
 mkdir test lib
 touch index.js
 2.Теперь ваша структура должна выглядеть следующим образом
 ./my-lib
    ├── index.js
    ├── lib
    ├── package.json
    └── test
    3.Для целей этого руководства мы напишем очень простую библиотеку. Наша библиотека будет складывать два числа и возвращать результат.
    const adder = require('my-lib');
    const added = adder(1, 2);
    4.Тесты: npm install mocha sinon chai
    Mocha — это средство для запуска тестов, которое мы будем использовать. Mocha по умолчанию запускает все файлы тестов в ./test каталоге вашего проекта.

    Давайте создадим нашу index.js для тестов. touch test/index.js

    Откройте ее, и давайте напишем наш первый тест:

    const sinon = require('sinon');
const expect = require('chai').expect;
const adder = require('..');

let sandbox;

beforeEach(function () {
    sandbox = sinon.sandbox.create();
});

afterEach(function () {
    sandbox.restore();
});

describe('#adder', function () {
  it('should add two numbers', function (done) {
    done();
  });
});

Мы импортировали наш тестовый модуль и библиотеку, которую тестируем (lib), а затем настроили методы beforeEach и afterEach. Методы beforeEach и afterEach будут запускаться перед каждым it тестом. Это необходимо для того, чтобы наша тестовая среда оставалась полностью чистой между тестами.

Затем мы создаём наш блок describe . Блоки описания обычно называются в соответствии с классом, методом или функцией. Это довольно гибко. Вы можете вкладывать блоки описания друг в друга. Блоки описания принимают два аргумента: строку, описывающую то, что вы тестируете, и функцию обратного вызова.

Внутри этой функции обратного вызова вы вводите блоки it для проверки конкретного поведения того, что вы «описали», при определённых условиях.

it принимает те же аргументы, что и describe: строковое описание, а затем функцию, но функция it принимает обратный вызов done , который должен быть вызван по завершении работы функции, иначе ваш тест завершится ошибкой из-за слишком долгого выполнения.
5.Теперь давайте запустим mocha ./test/ и посмотрим, что получится.
 mocha ./test/       

6.  Давайте отредактируем наш тест, чтобы сделать несколько реальных утверждений. Мы вызовем adder и присвоим значение переменной, а затем настроим ожидания для этой переменной.
describe('#adder', function () {
  it('should add two numbers', function (done) {
    const added = adder(1, 2);
    expect(added).to.equal(3);
    expect(added).to.be.a('Number');
    done();
  });
}); 
Отредактируем наш скрипт package.json test:
 "scripts": {
     "test": "mocha ./test"
   },
7.Теперь, если мы запустим npm run test, мы должны увидеть сбой.
 $ npm run test                                                                                                                                                                                                                                                                                       #adder
called
    1) should add two numbers

  0 passing (2s)
  1 failing
Это хорошо! Вы разобрались с «красной» частью красно-зелёного рефактора.

Давайте теперь напишем нашу реальную библиотеку. Мы знаем, как должен выглядеть наш API, у нас есть готовый тест для проверки, теперь нам просто нужно, чтобы тесты прошли, и мы сможем отправить код.

Исходя из первой части этого документа, мы хотим, чтобы по умолчанию экспорт нашей библиотеки был функцией. Давайте настроим эту структуру в index.
module.exports = function () {
  
}
8.После этого мы понимаем, что нам нужно, чтобы функция принимала два аргумента и возвращала их сумму.
module.exports = function (num1, num2) {
  return (num1 + num2)
}
  


